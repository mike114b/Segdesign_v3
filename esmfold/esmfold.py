import os
#import biotite.structure.io as bsio
import torch
import esm
import argparse
import shutil
from datetime import datetime
#from esmfold_report import data_organization

model = esm.pretrained.esmfold_v1()
model = model.eval().cuda()

def parse_args():
    parser = argparse.ArgumentParser(description='Protein sequence prediction', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--input_folder', type=str, help='Folder for storing sequence files')
    parser.add_argument('--output_folder', type=str, help='Folder for storing output files')
    

    return parser.parse_args()

#读取fasta文件中的序列，输出序列列表
def extract_sequences(file_path):
    sequences = []
    with open(file_path, "r") as f:
        file_content = f.read()
    lines = file_content.strip().split('\n')
    i = 1
    while i < len(lines):
        sequence = lines[i]
        sequences.append(sequence)
        i += 2
    return sequences

#输入单序列，输出pdb字符串
def sequence_to_pdb(sequence):
    with torch.no_grad():
        output = model.infer_pdb(sequence)
    return output

#输入fasta文件，输出fasta文件中每条序列的预测结果（pdb文件）
def structure_prediction(file_path, output_folder):
    print('Now start structure prediction!')
    sequences = extract_sequences(file_path)
    print('file_path:', file_path)
    print('file_path_sequence:', sequences)
    file_name = os.path.basename(file_path).rsplit('.')[0]
    folder = os.path.join(output_folder, file_name)
    print('folder:', folder)
    if not os.path.exists(folder):  ##新建文件夹
        os.makedirs(folder, exist_ok=True)
    now = datetime.now()
    header = [
        "HEADER    GENERATED BY ESMFOLD              {:%d-%b-%y}".format(now)
    ]
    for i in range(len(sequences)):
        sequence = sequences[i]
        output = sequence_to_pdb(sequence)
        #print('output:', output)
        print(f'{file_path}')
        print(f'The structure of sequence {i} has been generated.')
        out_path = os.path.join(output_folder, file_name, f'{file_name}_{i}.pdb')
        print('out_path:', out_path)
        # 步骤1：将文本按换行符分割成行列表
        lines = output.split('\n')

        # 步骤2：过滤掉包含"PARENT"的行（列表推导式）
        filtered_lines = [line for line in lines if "PARENT" not in line]

        # 步骤3：将过滤后的行重新拼接成完整文本
        output_fix = '\n'.join(filtered_lines)

        with open(out_path, "w") as f:
            for line in header:
                f.write(line.ljust(80) + '\n')
            f.write(output_fix)
    return sequences, folder

#批量预测
def structure_prediction_filter_all(input_folder, output_pdb_folder):
    files = os.listdir(input_folder)
    for file in files:
        file_path = os.path.join(input_folder, file)
        sequences, pdb_folder = structure_prediction(file_path, output_pdb_folder)
    return




def main():
    args = parse_args()
    input_folder = os.path.expanduser(args.input_folder)
    output_folder = os.path.expanduser(args.output_folder)
    #plddt_threshold = args.plddt_threshold
    #seq_range_str = args.design_seq
    output_pdb_folder = os.path.join(output_folder, 'structure_prediction_files')
    #output_filter_folder = os.path.join(output_folder, 'filter_files')
    if not os.path.exists(output_pdb_folder):  ##新建文件夹
        os.makedirs(output_pdb_folder, exist_ok=True)

    structure_prediction_filter_all(
        input_folder=input_folder,
        output_pdb_folder=output_pdb_folder
    )


if __name__ == '__main__':
    main()